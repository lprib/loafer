#!/usr/bin/python3
import argparse
import shlex
import subprocess
import sys
import xml.etree.ElementTree as et
from pathlib import Path

TARGET_TYPE_ARTIFACT = 0
TARGET_TYPE_TAG = 1
TARGET_TYPE_SCRIPT = 2

STAGE_COMPILE = 0
STAGE_LINK = 1
STAGE_RUN = 2

compiler_options = ["main", "inc", "src", "compflags", "linkflags", "complinkflags", "runflags", "cc"]

def parse_compile_config(elem):
    config = {x: [] for x in compiler_options}

    for option_name in compiler_options:
        option_elems = elem.findall(option_name)
        for option_elem in option_elems:
            typ = option_elem.attrib.get("type")
            if typ == "glob":
                config[option_name].extend(map(str, Path(".").glob(option_elem.text)))
            elif typ == "shell":
                config[option_name].extend(shlex.split(option_elem.text))
            else:
                config[option_name].extend(option_elem.text.split())
    return config

def concat_compile_configs(configs):
    out = {}
    for key in configs[0].keys():
        out[key] = []
        for c in configs:
            out[key].extend(c[key])
    return out

class Artifact:
    def __init__(self, elem):
        self.tags = elem.attrib["tags"].split(" ") if "tags" in elem.attrib else []
        self.compiler_config = parse_compile_config(elem)

def run_process(process_args, project_config, *args, **kwargs):
    if project_config["verbose"]:
        # In shell mode, we only send a single string, don't try to join it
        if kwargs["shell"] == True:
            print(process_args)
        else:
            print(" ".join(process_args))
    subprocess.call(process_args, *args, **kwargs)


def build_target(artifact, artifact_name, tags, project_config):
    if project_config["verbose"]: print(f"Compiling artifact {artifact_name}")

    configs = [tags[t][1] for t in artifact.tags]
    configs.append(artifact.compiler_config)
    if "global" in tags:
        configs.append(tags["global"][1])
    
    config = concat_compile_configs(configs)
    
    # create out dir
    out_dir = project_config["outdir"] / artifact_name
    out_dir.mkdir(parents=True, exist_ok=True)

    objects = []

    full_compile_flags = config["complinkflags"] + config["compflags"] + ["-I" + str(include) for include in config["inc"]]

    for source in config["main"] + config["src"]:
        object_file = str(out_dir / Path(source).stem) + ".o"
        objects.append(object_file)
        run_process(["gcc", "-c", str(source), "-o", str(object_file)] + full_compile_flags, project_config)
    
    if project_config["stage"] <= STAGE_COMPILE: return
    if project_config["verbose"]: print(f"Linking artifact {artifact_name}")
    
    exe_name = str(out_dir / artifact_name)
    run_process(["gcc", "-o", exe_name] + objects + config["complinkflags"] + config["linkflags"], project_config)

    if project_config["stage"] <= STAGE_LINK: return
    if project_config["verbose"]: print(f"Running artifact {artifact_name}")
    
    run_process([exe_name] + config["runflags"], project_config)

def construct_lookup_dict(root, collection_elem_name, typ, construct_from_elem):
    return {e.attrib["id"]: (typ, construct_from_elem(e)) for e in root.find(collection_elem_name)}

def main():
    parser = argparse.ArgumentParser(prog="Loafer", description="Simple C build and test system")
    parser.add_argument("targets", metavar="TARGET", nargs="+")
    parser.add_argument("-v", "--verbose", action="store_true", help="show compile commands")
    stage_group = parser.add_mutually_exclusive_group()
    stage_group.add_argument("-c", "--compile", action="store_const", const=STAGE_COMPILE, dest='stage', help="run the compile step")
    stage_group.add_argument("-l", "--link", action="store_const", const=STAGE_LINK, dest="stage", help="run the link step")
    stage_group.add_argument("-r", "--run", action="store_const", const=STAGE_RUN, dest="stage", help="run target after linking")
    args = parser.parse_args()

    root = et.parse("loafer.xml").getroot()

    tags = construct_lookup_dict(root, "tags", TARGET_TYPE_TAG, lambda e: parse_compile_config(e))
    artifacts = construct_lookup_dict(root, "artifacts", TARGET_TYPE_ARTIFACT, lambda e: Artifact(e))
    scripts = construct_lookup_dict(root, "scripts", TARGET_TYPE_SCRIPT, lambda e: e.text)

    # dictionary of id -> (type, object)
    targets = {**tags, **artifacts, **scripts}

    project_config = {}
    project_config["outdir"] = Path(root.findtext("outdir"))
    project_config["stage"] = args.stage or STAGE_RUN
    project_config["verbose"] = args.verbose
    
    for targetname in args.targets:
        if targetname in targets:
            typ, obj = targets[targetname]
            if typ == TARGET_TYPE_ARTIFACT:
                build_target(obj, targetname, tags, project_config)
            elif typ == TARGET_TYPE_TAG:
                for artifact_name, (_, artifact) in artifacts.items():
                    if targetname in artifact.tags:
                        build_target(artifact, artifact_name, tags, project_config)
            if typ == TARGET_TYPE_SCRIPT:
                run_process(obj, project_config, shell=True)
        else:
            print(f"Unknown tag or artifact {targetname}", file=sys.stderr)


if __name__ == "__main__":
    main()